<!-- vim: set expandtab ft=html : -->
        <hr
            style="
                width: 100%;
                height: 2px;
                border-style: inset;
                display: block;
                background-color: #192021;
                border: none;
                border-top: 2px solid #e0d3af;
            " />
        <p
            class="tight"
            style="text-wrap: balance; max-width: 100vw; text-align: center; font-size: 75%">
            <span
                style='
                    font-family: Junicode,
                    font-size: 75%;
                    font-feature-settings: "smcp" 1;
                '>
                ###LATINDATE###
            </span>
        </p>
        <hr
            style="
                width: 100%;
                height: 2px;
                border-style: inset;
                display: block;
                background-color: #192021;
                border: none;
                border-top: 2px solid #e0d3af;
            " />
        <p></p>

        <script>
            function wrapFirstChar(paragraphs) {
                for (const p of paragraphs) {
                    const nodes = Array.from(p.childNodes);

                    for (const node of nodes) {
                        if (node.nodeType === Node.TEXT_NODE) {
                            const text = node.textContent.trimStart();

                            if (text.length === 0) continue;

                            const index = node.textContent.indexOf(text[0]);
                            const before = node.textContent.slice(0, index);
                            const rest = node.textContent.slice(index + 1);
                            const span = document.createElement("span");

                            span.classList.add("dropcap");
                            span.textContent = text[0];

                            const frag = document.createDocumentFragment();

                            if (before) frag.appendChild(document.createTextNode(before));

                            frag.appendChild(span);

                            if (rest) frag.appendChild(document.createTextNode(rest));

                            p.replaceChild(frag, node);
                            break;
                        }
                    }
                }
            }

            document.addEventListener("DOMContentLoaded", async function () {
                await document.fonts.ready;
                const paragraphs = document.querySelectorAll("p, blockquote");
                wrapFirstChar(paragraphs);

                function wrapChars(node) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        const text = node.textContent;
                        const frag = document.createDocumentFragment();

                        for (let i = 0; i < text.length; i++) {
                            const span = document.createElement("span");

                            span.classList.add("char");
                            span.textContent = text[i];

                            if (text[i] === "s" || text[i] === "J") {
                                span.classList.add("pending-transform");
                            }

                            frag.appendChild(span);
                        }
                        node.parentNode.replaceChild(frag, node);
                    } else if (
                        node.nodeType === Node.ELEMENT_NODE &&
                        node.nodeName !== "SCRIPT" &&
                        node.nodeName !== "STYLE"
                    ) {
                        Array.from(node.childNodes).forEach((child) => wrapChars(child));
                    }
                }

                wrapChars(document.body);

                document.body.style.visibility = "visible";
/*
                async function animateParagraphs(paragraphs, batchSize = 16) {
                    for (const p of paragraphs) {
                        const charSpans = Array.from(p.querySelectorAll(".char"));
                        let i = 0;

                        function insideAnimateBatch() {
                            for (let j = 0; j < batchSize && i < charSpans.length; j++, i++) {
                                const span = charSpans[i];
                                span.classList.add("visible");
                                if (span.classList.contains("pending-transform")) {
                                    span.classList.remove("pending-transform");
                                    span.classList.add("transformed");
                                }
                            }
                            if (i < charSpans.length) {
                                requestAnimationFrame(insideAnimateBatch);
                            }
                        }
                        insideAnimateBatch();
                    }
                }*/
                /*
                function fadeOutIn(span) {
                    span.classList.add("fading");

                    setTimeout(() => {
                        span.classList.remove("pending-transform", "fading");
                        span.classList.add("transformed");
                    }, 505);
                }

                async function animateParagraphs(paragraphs) {
                    for (const p of paragraphs) {
                        const charSpans = p.querySelectorAll(".char");

                        for (const span of charSpans) {
                            span.classList.add("visible");
                            if (span.classList.contains("pending-transform")) {
                                fadeOutIn(span);
                            }
                        }
                    }
                }*/
                async function animateParagraphs(paragraphs, fadeDuration = 200, stagger = 5) {
                    for (const p of paragraphs) {
                        const spans = p.querySelectorAll('.char.pending-transform');

                        spans.forEach(span => {
                            span.classList.add('fading');
                        });

                        await new Promise(resolve => setTimeout(resolve, fadeDuration));

                        spans.forEach(span => {
                            span.classList.remove('pending-transform', 'fading');
                            span.classList.add('transformed');
                        });

                        await new Promise(resolve => setTimeout(resolve, stagger));
                    }
                }

                await animateParagraphs(paragraphs);

                const lastPara = document.querySelector("p:last-of-type");

                if (lastPara) {
                    const shim = document.createElement("span");
                    shim.textContent = "\u00A0.";
                    shim.style.whiteSpace = "nowrap";
                    shim.style.display = "inline";
                    shim.style.opacity = "0";
                    shim.style.fontSize = "0.01px";
                    shim.setAttribute("aria-hidden", "true");
                    lastPara.appendChild(shim);
                }
            });

            function setTheme(dark) {
                document.documentElement.classList.toggle("dark-mode", dark);
                document.getElementById("theme-toggle").textContent = dark ? "☼" : "●";
            }

            function getStoredTheme() {
                return localStorage.getItem("theme");
            }

            function storeTheme(theme) {
                localStorage.setItem("theme", theme);
            }

            (function () {
                const stored = getStoredTheme();
                let dark = false;

                if (stored === "dark") dark = true;
                else if (stored === "light") dark = false;
                else dark = window.matchMedia("(prefers-color-scheme: dark)").matches;

                setTheme(dark);
            })();

            document.getElementById("theme-toggle").onclick = function () {
                const dark = !document.documentElement.classList.contains("dark-mode");
                setTheme(dark);
                storeTheme(dark ? "dark" : "light");
            };

            window.addEventListener("DOMContentLoaded", function () {
                document.documentElement.classList.remove("notransition");
            });

            (function () {
                const debounceDelay = 50;
                const reentryDelay = 25;

                let resizeTextObject;
                let isProcessing = false;

                function versify(el) {
                    if (isProcessing) {
                        setTimeout(() => versify(el), reentryDelay);
                        return;
                    }

                    isProcessing = true;

                    try {
                        const rect = el.getBoundingClientRect();
                        el.style.minWidth = rect.width + "px";
                        el.style.minHeight = rect.height + "px";
                        el.style.boxSizing = "border-box";
                        const rawText = el.dataset.raw || el.textContent;

                        if (!el.dataset.raw) {
                            el.dataset.raw = rawText;
                        }

                        const tempTextNode = document.createTextNode(rawText);

                        el.innerHTML = "";
                        el.appendChild(tempTextNode);

                        const range = document.createRange();
                        const lineH = parseFloat(getComputedStyle(el).lineHeight);
                        const threshold = lineH * 0.8;
                        const DPR = window.devicePixelRatio || 1;

                        if (!lineH || isNaN(lineH) || lineH < 1) {
                            requestAnimationFrame(() => versify(el));
                            return;
                        }

                        let prevTop = null;
                        const breaks = [0];

                        for (let i = 0; i < rawText.length; i++) {
                            range.setStart(tempTextNode, i);
                            range.setEnd(tempTextNode, i + 1);

                            const rect = range.getBoundingClientRect();
                            const top = Math.round(rect.top * DPR) / DPR;

                            if (prevTop === null) {
                                prevTop = top;
                            } else if (top - prevTop > threshold) {
                                breaks.push(i);
                                prevTop = top;
                            }
                        }

                        breaks.push(rawText.length);
                        el.innerHTML = "";

                        if (breaks.length <= 2) {
                            console.log(JSON.stringify(breaks));
                            //el.textContent = '“' + rawText.replace(/[\r\n]+/g, '').replace(/ {2,}/g, '').trim() + '”';
                            //return;
                            el.innerHTML =
                                '<span class="vline">' +
                                rawText
                                    .replace(/ {2,}/g, "")
                                    .trim() +
                                '”</span>';
                            return;
                        }

                        for (let j = 0; j < breaks.length - 1; j++) {
                            const span = document.createElement("span");
                            span.className = "vline";

                            const from = breaks[j],
                                to = breaks[j + 1];

                            const segment = rawText.slice(from, to);

                            if (j === breaks.length - 2 && !/[“"”]\s*$/.test(segment)) {
                                const match = segment.match(/(.*?)(\s*)$/);
                                const core = match ? match[1] : segment;
                                const spaces = match ? match[2] : "";

                                span.textContent = core;

                                const quote = document.createElement("span");

                                quote.className = "closer";
                                quote.textContent = "”";
                                span.appendChild(quote);
                                span.appendChild(document.createTextNode(spaces));
                            } else {
                                span.textContent = segment;
                            }

                            el.appendChild(span);
                        }
                    } finally {
                        setTimeout(() => {
                            el.style.minWidth = "";
                            el.style.minHeight = "";
                        }, 0);
                        isProcessing = false;
                    }
                }

                function processAllVerses() {
                    requestAnimationFrame(() => {
                        document.querySelectorAll("blockquote.verse").forEach((el) => versify(el));
                    });
                }

                function redraw() {
                    clearTimeout(resizeTextObject);
                    resizeTextObject = setTimeout(processAllVerses, debounceDelay);
                }

                window.addEventListener("load", () => {
                    setTimeout(processAllVerses, 150);
                });
                window.addEventListener("resize", redraw);
                window.addEventListener("visualViewport.resize", redraw);
                window.addEventListener("focus", redraw);
                window.addEventListener("blur", redraw);
                window.addEventListener("pageshow", redraw);
                window.addEventListener("orientationchange", () => {
                    setTimeout(redraw, 500);
                });

                let lastScale = window.visualViewport?.scale || 1;

                setInterval(() => {
                    const currentScale = window.visualViewport?.scale || 1;

                    if (Math.abs(currentScale - lastScale) > 0.001) {
                        lastScale = currentScale;
                        redraw();
                    }
                }, 256);

                function isSafari() {
                  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                }

                function debounce(func, wait) {
                  let timeout;
                  return function(...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                  };
                }

                if (isSafari()) {
                  window.addEventListener('scroll', debounce(function() {
                    if (typeof redraw === 'function') {
                      redraw();
                    }
                  }, 250));
                }

            })();
        </script>
        <script src="housestyle.js"></script>
    </body>
</html>
